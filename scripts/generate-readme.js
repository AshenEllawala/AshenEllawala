/**
 * scripts/generate-readme.js
 *
 * Node.js script that updates the README.md between AUTO-GEN markers
 * Requires GITHUB_TOKEN provided by the workflow.
 */

const fs = require('fs');
const path = require('path');
const { Octokit } = require('@octokit/rest');

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const REPO = process.env.GITHUB_REPOSITORY; // e.g. ashenellawala/<repo>
if (!GITHUB_TOKEN || !REPO) {
  console.error("Missing GITHUB_TOKEN or GITHUB_REPOSITORY environment variable.");
  process.exit(1);
}

const [owner, repo] = REPO.split('/');

const octokit = new Octokit({ auth: GITHUB_TOKEN });

async function getRepoLanguages() {
  try {
    const resp = await octokit.repos.listLanguages({ owner, repo });
    return resp.data; // {JavaScript: 12345, HTML: 6789, ...}
  } catch (err) {
    console.error("Failed to fetch languages:", err);
    return {};
  }
}

function buildLanguagesSection(langsObj) {
  const entries = Object.entries(langsObj);
  if (!entries.length) return 'No language data available for this repository.';

  const total = entries.reduce((sum, [, v]) => sum + v, 0);
  // sort descending
  entries.sort((a, b) => b[1] - a[1]);

  const lines = entries.map(([lang, bytes]) => {
    const percent = ((bytes / total) * 100).toFixed(1);
    return `- **${lang}** ‚Äî ${percent}%`;
  });

  return lines.join('\n');
}

async function run() {
  const readmePath = path.join(process.cwd(), 'README.md');
  if (!fs.existsSync(readmePath)) {
    console.error("README.md not found at repo root.");
    process.exit(1);
  }
  const readme = fs.readFileSync(readmePath, 'utf8');

  const startMarker = '<!-- AUTO-GEN:START -->';
  const endMarker = '<!-- AUTO-GEN:END -->';
  const startIdx = readme.indexOf(startMarker);
  const endIdx = readme.indexOf(endMarker);

  if (startIdx === -1 || endIdx === -1) {
    console.error("AUTO-GEN markers not found in README.md. Please include them.");
    process.exit(1);
  }

  // Fetch languages
  const langs = await getRepoLanguages();
  const langSection = buildLanguagesSection(langs);

  const timestamp = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '') + ' UTC';

  const newBlock = [
    startMarker,
    '<!-- The section below is automatically generated by .github/workflows/update-readme.yml -->',
    '### ‚è±Ô∏è Last updated',
    `*${timestamp}*`,
    '',
    '### üìà Top languages (from this repo)',
    '',
    langSection,
    '',
    '### üìä GitHub Stats',
    '<p align="center">',
    `  <img src="https://github-readme-stats.vercel.app/api?username=${owner}&show_icons=true&theme=tokyonight" alt="GitHub Stats" />`,
    '</p>',
    endMarker
  ].join('\n');

  const newReadme = readme.slice(0, startIdx) + newBlock + readme.slice(endIdx + endMarker.length);

  if (newReadme === readme) {
    console.log("README unchanged ‚Äî nothing to update.");
    return;
  }

  fs.writeFileSync(readmePath, newReadme, 'utf8');
  console.log("README updated locally. Changes will be pushed by the workflow.");
}

run().catch(err => {
  console.error(err);
  process.exit(1);
});
